# 2.7 Set: Conjuntos de valores únicos

El objeto `Set` permite almacenar **valores únicos** (sin duplicados) y mantener el **orden de inserción**. Es ideal para eliminar duplicados o comprobar pertenencia de forma eficiente.

!!! info "Valores únicos y comparación"
    `Set` considera dos valores iguales siguiendo la semántica **SameValueZero**:
    `NaN` se considera igual a `NaN`, y `+0` y `-0` se consideran el mismo valor.

---

## 📌 ¿Qué es un `Set`?

Un `Set` es una colección de elementos **sin índices** y **sin claves**, donde cada valor aparece **como mucho una vez**.
Se recorre en el orden en el que se insertaron los elementos.

---

## 📌 Crear un `Set`

### Literal y desde arrays

```js
// Set vacío
const s1 = new Set();

// Desde un array (los duplicados se eliminan)
const s2 = new Set([1, 2, 2, 3, 3, 4]); // Set {1, 2, 3, 4}
```

### Eliminar duplicados rápidamente

```js
const numeros = [1, 2, 2, 3, 4, 4, 5];
const unicos = [...new Set(numeros)]; // [1, 2, 3, 4, 5]
```

---

## 📌 Métodos principales

### Añadir y comprobar

```js
const letras = new Set();
letras.add("a");        // añade "a"
letras.add("b");        // añade "b"
letras.add("a");        // duplicado: no tiene efecto

letras.has("a");        // true
letras.has("z");        // false
```

### Eliminar elementos

```js
letras.delete("b");     // elimina "b" si existe
letras.delete("x");     // false si no existía
```

### Tamaño y limpieza

```js
letras.size;            // número de elementos del Set
letras.clear();         // elimina todos los elementos
```

---

## 📌 Recorrer un `Set`

### Con `for...of` y `forEach`

```js
const colores = new Set(["rojo", "verde", "azul"]);

for (const color of colores) {
  console.log(color);
}

colores.forEach(c => console.log(c));
```

---

## 📌 Convertir entre `Set` y `Array`

### De `Array` a `Set` y vuelta

```js
const arr = ["a", "b", "b", "c"];
const set = new Set(arr);      // Set {"a","b","c"}
const backToArray = [...set];  // ["a","b","c"]
```

---

## 📌 Operaciones típicas de conjuntos

> Aunque `Set` no trae métodos nativos para unión/intersección/diferencia, se pueden construir fácilmente.

### Unión

```js
const A = new Set([1, 2, 3]);
const B = new Set([3, 4, 5]);
const union = new Set([...A, ...B]);          // Set {1,2,3,4,5}
```

### Intersección

```js
const interseccion = new Set([...A].filter(x => B.has(x))); // Set {3}
```

### Diferencia

```js
const diferencia = new Set([...A].filter(x => !B.has(x)));  // Set {1,2}
```

---

## 📌 Casos de uso frecuentes

### Quitar duplicados de una lista

```js
const emails = ["a@x.com", "b@x.com", "a@x.com"];
const unicos = [...new Set(emails)]; // ["a@x.com","b@x.com"]
```

### Comprobación rápida de pertenencia

```js
const palabrasProhibidas = new Set(["spam", "fake", "scam"]);
palabrasProhibidas.has("spam"); // true
```

---

## 📝 Preguntas de repaso

!!! question "Reflexiona sobre lo aprendido"
        1. ¿Qué ocurre al llamar a `add` con un valor que ya existe en el `Set`?
        2. ¿Qué devuelve la propiedad `.size` de un `Set`?
        3. ¿Cómo convertirías un `Set` en un array?
        4. ¿Cómo construirías la **intersección** de dos `Set` `A` y `B`?
        5. ¿Por qué `NaN` sí se considera igual a `NaN` dentro de un `Set`?
