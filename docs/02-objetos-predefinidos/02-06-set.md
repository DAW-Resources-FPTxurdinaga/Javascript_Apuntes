# 2.7 Set: Conjuntos de valores Ãºnicos

El objeto `Set` permite almacenar **valores Ãºnicos** (sin duplicados) y mantener el **orden de inserciÃ³n**. Es ideal para eliminar duplicados o comprobar pertenencia de forma eficiente.

!!! info "Valores Ãºnicos y comparaciÃ³n"
    `Set` considera dos valores iguales siguiendo la semÃ¡ntica **SameValueZero**:
    `NaN` se considera igual a `NaN`, y `+0` y `-0` se consideran el mismo valor.

---

## ğŸ“Œ Â¿QuÃ© es un `Set`?

Un `Set` es una colecciÃ³n de elementos **sin Ã­ndices** y **sin claves**, donde cada valor aparece **como mucho una vez**.
Se recorre en el orden en el que se insertaron los elementos.

---

## ğŸ“Œ Crear un `Set`

### Literal y desde arrays

```js
// Set vacÃ­o
const s1 = new Set();

// Desde un array (los duplicados se eliminan)
const s2 = new Set([1, 2, 2, 3, 3, 4]); // Set {1, 2, 3, 4}
```

### Eliminar duplicados rÃ¡pidamente

```js
const numeros = [1, 2, 2, 3, 4, 4, 5];
const unicos = [...new Set(numeros)]; // [1, 2, 3, 4, 5]
```

---

## ğŸ“Œ MÃ©todos principales

### AÃ±adir y comprobar

```js
const letras = new Set();
letras.add("a");        // aÃ±ade "a"
letras.add("b");        // aÃ±ade "b"
letras.add("a");        // duplicado: no tiene efecto

letras.has("a");        // true
letras.has("z");        // false
```

### Eliminar elementos

```js
letras.delete("b");     // elimina "b" si existe
letras.delete("x");     // false si no existÃ­a
```

### TamaÃ±o y limpieza

```js
letras.size;            // nÃºmero de elementos del Set
letras.clear();         // elimina todos los elementos
```

---

## ğŸ“Œ Recorrer un `Set`

### Con `for...of` y `forEach`

```js
const colores = new Set(["rojo", "verde", "azul"]);

for (const color of colores) {
  console.log(color);
}

colores.forEach(c => console.log(c));
```

---

## ğŸ“Œ Convertir entre `Set` y `Array`

### De `Array` a `Set` y vuelta

```js
const arr = ["a", "b", "b", "c"];
const set = new Set(arr);      // Set {"a","b","c"}
const backToArray = [...set];  // ["a","b","c"]
```

---

## ğŸ“Œ Operaciones tÃ­picas de conjuntos

> Aunque `Set` no trae mÃ©todos nativos para uniÃ³n/intersecciÃ³n/diferencia, se pueden construir fÃ¡cilmente.

### UniÃ³n

```js
const A = new Set([1, 2, 3]);
const B = new Set([3, 4, 5]);
const union = new Set([...A, ...B]);          // Set {1,2,3,4,5}
```

### IntersecciÃ³n

```js
const interseccion = new Set([...A].filter(x => B.has(x))); // Set {3}
```

### Diferencia

```js
const diferencia = new Set([...A].filter(x => !B.has(x)));  // Set {1,2}
```

---

## ğŸ“Œ Casos de uso frecuentes

### Quitar duplicados de una lista

```js
const emails = ["a@x.com", "b@x.com", "a@x.com"];
const unicos = [...new Set(emails)]; // ["a@x.com","b@x.com"]
```

### ComprobaciÃ³n rÃ¡pida de pertenencia

```js
const palabrasProhibidas = new Set(["spam", "fake", "scam"]);
palabrasProhibidas.has("spam"); // true
```

---

## ğŸ“ Preguntas de repaso

!!! question "Reflexiona sobre lo aprendido"
        1. Â¿QuÃ© ocurre al llamar a `add` con un valor que ya existe en el `Set`?
        2. Â¿QuÃ© devuelve la propiedad `.size` de un `Set`?
        3. Â¿CÃ³mo convertirÃ­as un `Set` en un array?
        4. Â¿CÃ³mo construirÃ­as la **intersecciÃ³n** de dos `Set` `A` y `B`?
        5. Â¿Por quÃ© `NaN` sÃ­ se considera igual a `NaN` dentro de un `Set`?
